{"version":3,"file":"static/webpack/static/development/pages/index.js.4dde578bb31e3d0053ca.hot-update.js","sources":["webpack:///./node_modules/three/examples/jsm/postprocessing/BloomPass.js","webpack:///./node_modules/three/examples/jsm/shaders/ConvolutionShader.js","webpack:///./webgl/index.js"],"sourcesContent":["/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nimport {\n\tAdditiveBlending,\n\tLinearFilter,\n\tRGBAFormat,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector2,\n\tWebGLRenderTarget\n} from \"../../../build/three.module.js\";\nimport { Pass } from \"../postprocessing/Pass.js\";\nimport { CopyShader } from \"../shaders/CopyShader.js\";\nimport { ConvolutionShader } from \"../shaders/ConvolutionShader.js\";\n\nvar BloomPass = function ( strength, kernelSize, sigma, resolution ) {\n\n\tPass.call( this );\n\n\tstrength = ( strength !== undefined ) ? strength : 1;\n\tkernelSize = ( kernelSize !== undefined ) ? kernelSize : 25;\n\tsigma = ( sigma !== undefined ) ? sigma : 4.0;\n\tresolution = ( resolution !== undefined ) ? resolution : 256;\n\n\t// render targets\n\n\tvar pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };\n\n\tthis.renderTargetX = new WebGLRenderTarget( resolution, resolution, pars );\n\tthis.renderTargetX.texture.name = \"BloomPass.x\";\n\tthis.renderTargetY = new WebGLRenderTarget( resolution, resolution, pars );\n\tthis.renderTargetY.texture.name = \"BloomPass.y\";\n\n\t// copy material\n\n\tif ( CopyShader === undefined )\n\t\tconsole.error( \"BloomPass relies on CopyShader\" );\n\n\tvar copyShader = CopyShader;\n\n\tthis.copyUniforms = UniformsUtils.clone( copyShader.uniforms );\n\n\tthis.copyUniforms[ \"opacity\" ].value = strength;\n\n\tthis.materialCopy = new ShaderMaterial( {\n\n\t\tuniforms: this.copyUniforms,\n\t\tvertexShader: copyShader.vertexShader,\n\t\tfragmentShader: copyShader.fragmentShader,\n\t\tblending: AdditiveBlending,\n\t\ttransparent: true\n\n\t} );\n\n\t// convolution material\n\n\tif ( ConvolutionShader === undefined )\n\t\tconsole.error( \"BloomPass relies on ConvolutionShader\" );\n\n\tvar convolutionShader = ConvolutionShader;\n\n\tthis.convolutionUniforms = UniformsUtils.clone( convolutionShader.uniforms );\n\n\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = BloomPass.blurX;\n\tthis.convolutionUniforms[ \"cKernel\" ].value = ConvolutionShader.buildKernel( sigma );\n\n\tthis.materialConvolution = new ShaderMaterial( {\n\n\t\tuniforms: this.convolutionUniforms,\n\t\tvertexShader: convolutionShader.vertexShader,\n\t\tfragmentShader: convolutionShader.fragmentShader,\n\t\tdefines: {\n\t\t\t\"KERNEL_SIZE_FLOAT\": kernelSize.toFixed( 1 ),\n\t\t\t\"KERNEL_SIZE_INT\": kernelSize.toFixed( 0 )\n\t\t}\n\n\t} );\n\n\tthis.needsSwap = false;\n\n\tthis.fsQuad = new Pass.FullScreenQuad( null );\n\n};\n\nBloomPass.prototype = Object.assign( Object.create( Pass.prototype ), {\n\n\tconstructor: BloomPass,\n\n\trender: function ( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\n\n\t\t// Render quad with blured scene into texture (convolution pass 1)\n\n\t\tthis.fsQuad.material = this.materialConvolution;\n\n\t\tthis.convolutionUniforms[ \"tDiffuse\" ].value = readBuffer.texture;\n\t\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = BloomPass.blurX;\n\n\t\trenderer.setRenderTarget( this.renderTargetX );\n\t\trenderer.clear();\n\t\tthis.fsQuad.render( renderer );\n\n\n\t\t// Render quad with blured scene into texture (convolution pass 2)\n\n\t\tthis.convolutionUniforms[ \"tDiffuse\" ].value = this.renderTargetX.texture;\n\t\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = BloomPass.blurY;\n\n\t\trenderer.setRenderTarget( this.renderTargetY );\n\t\trenderer.clear();\n\t\tthis.fsQuad.render( renderer );\n\n\t\t// Render original scene with superimposed blur to texture\n\n\t\tthis.fsQuad.material = this.materialCopy;\n\n\t\tthis.copyUniforms[ \"tDiffuse\" ].value = this.renderTargetY.texture;\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\n\n\t\trenderer.setRenderTarget( readBuffer );\n\t\tif ( this.clear ) renderer.clear();\n\t\tthis.fsQuad.render( renderer );\n\n\t}\n\n} );\n\nBloomPass.blurX = new Vector2( 0.001953125, 0.0 );\nBloomPass.blurY = new Vector2( 0.0, 0.001953125 );\n\nexport { BloomPass };\n","/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Convolution shader\n * ported from o3d sample to WebGL / GLSL\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\n */\n\nimport {\n\tVector2\n} from \"../../../build/three.module.js\";\n\nvar ConvolutionShader = {\n\n\tdefines: {\n\n\t\t\"KERNEL_SIZE_FLOAT\": \"25.0\",\n\t\t\"KERNEL_SIZE_INT\": \"25\"\n\n\t},\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"uImageIncrement\": { value: new Vector2( 0.001953125, 0.0 ) },\n\t\t\"cKernel\": { value: [] }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"uniform vec2 uImageIncrement;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\",\n\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\n\t\t\"uniform float cKernel[ KERNEL_SIZE_INT ];\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform vec2 uImageIncrement;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvec2 imageCoord = vUv;\",\n\t\t\"\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\",\n\n\t\t\"\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\",\n\n\t\t\"\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\",\n\t\t\"\t\timageCoord += uImageIncrement;\",\n\n\t\t\"\t}\",\n\n\t\t\"\tgl_FragColor = sum;\",\n\n\t\t\"}\"\n\n\n\t].join( \"\\n\" ),\n\n\tbuildKernel: function ( sigma ) {\n\n\t\t// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\n\n\t\tfunction gauss( x, sigma ) {\n\n\t\t\treturn Math.exp( - ( x * x ) / ( 2.0 * sigma * sigma ) );\n\n\t\t}\n\n\t\tvar i, values, sum, halfWidth, kMaxKernelSize = 25, kernelSize = 2 * Math.ceil( sigma * 3.0 ) + 1;\n\n\t\tif ( kernelSize > kMaxKernelSize ) kernelSize = kMaxKernelSize;\n\t\thalfWidth = ( kernelSize - 1 ) * 0.5;\n\n\t\tvalues = new Array( kernelSize );\n\t\tsum = 0.0;\n\t\tfor ( i = 0; i < kernelSize; ++ i ) {\n\n\t\t\tvalues[ i ] = gauss( i - halfWidth, sigma );\n\t\t\tsum += values[ i ];\n\n\t\t}\n\n\t\t// normalize the kernel\n\n\t\tfor ( i = 0; i < kernelSize; ++ i ) values[ i ] /= sum;\n\n\t\treturn values;\n\n\t}\n\n};\n\nexport { ConvolutionShader };\n","import * as THREE from 'three';\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';\nimport { FilmPass } from 'three/examples/jsm/postprocessing/FilmPass';\nimport { BloomPass } from 'three/examples/jsm/postprocessing/BloomPass';\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';\n\nimport { CAMERA_SETTINGS } from './utils/settings';\nimport Audio from './utils/audio';\nimport { getDimensions } from './utils';\n\nimport Sphere from './scene/sphere';\nimport Particles from './scene/particles';\n\n\nconst WebGL = function() {\n  const canvas = document.getElementById('webGL');\n  const { width , height } = getDimensions('webGL');\n\n  const scene = new THREE.Scene();\n  const camera = new THREE.PerspectiveCamera(CAMERA_SETTINGS.fov, width / height, CAMERA_SETTINGS.near, CAMERA_SETTINGS.far);\n  camera.position.set(0,0,20);\n\n  const renderer = new THREE.WebGLRenderer({ canvas , alpha: true });\n  renderer.setSize(width, height);\n  renderer.setClearColor(new THREE.Color('#010101'), 1.);\n  renderer.shadowMap.enabled = true;\n  renderer.gammaFactor = 2.2;\n  renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n  renderer.toneMapping = THREE.ReinhardToneMapping;\n\n  const composer = new EffectComposer(renderer);\n  composer.setSize(width, height);\n\n  const renderScene = new RenderPass(scene, camera);\n  composer.addPass(renderScene);\n\n  const bloomPass = new bloomPass(0.5);\n  composer.addPass(bloomPass);\n\n  const filmPass = new FilmPass(0.35,0.25, 648, false);\n  composer.addPass(filmPass)\n\n  const audio = new Audio();\n  const sphere = new Sphere();\n  const particles = new Particles();\n\n  this.load = async () => {\n    await audio.load();\n    sphere.setUp(audio);\n    scene.add(sphere.mesh);\n    await particles.setUp(audio);\n    scene.add(particles.points);\n  }\n\n  this.render = () => {\n    renderer.setAnimationLoop(\n      () => {\n        audio.update();\n        sphere.update();\n        particles.update();\n        // renderer.render(scene, camera);\n        composer.render();\n      }\n    )\n  }\n}\n\nexport default WebGL;"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;;;AAIA;AASA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAGA;AAGA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AANA;AACA;AAWA;AAGA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AALA;AAYA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAzCA;AA6CA;AACA;;;;;;;;;;;;;ACpIA;AAAA;AAAA;AAAA;;;;;;;AAQA;AAIA;AAEA;AAEA;AACA;AAHA;AAOA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAJA;AAQA;AAeA;AA4BA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAEA;AA1FA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAEA;AACA;AAHA;AAAA;AACA;AADA;AAKA;AACA;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;A","sourceRoot":""}