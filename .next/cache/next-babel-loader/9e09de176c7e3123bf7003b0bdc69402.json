{"ast":null,"code":"import _Number$EPSILON from \"@babel/runtime-corejs2/core-js/number/epsilon\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _Set from \"@babel/runtime-corejs2/core-js/set\";\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\nimport { BufferAttribute, BufferGeometry, InterleavedBuffer, InterleavedBufferAttribute, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, Vector2, Vector3 } from \"../../../build/three.module.js\";\nvar BufferGeometryUtils = {\n  computeTangents: function computeTangents(geometry) {\n    var index = geometry.index;\n    var attributes = geometry.attributes; // based on http://www.terathon.com/code/tangent.html\n    // (per vertex tangents)\n\n    if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {\n      console.warn('THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()');\n      return;\n    }\n\n    var indices = index.array;\n    var positions = attributes.position.array;\n    var normals = attributes.normal.array;\n    var uvs = attributes.uv.array;\n    var nVertices = positions.length / 3;\n\n    if (attributes.tangent === undefined) {\n      geometry.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));\n    }\n\n    var tangents = attributes.tangent.array;\n    var tan1 = [],\n        tan2 = [];\n\n    for (var i = 0; i < nVertices; i++) {\n      tan1[i] = new Vector3();\n      tan2[i] = new Vector3();\n    }\n\n    var vA = new Vector3(),\n        vB = new Vector3(),\n        vC = new Vector3(),\n        uvA = new Vector2(),\n        uvB = new Vector2(),\n        uvC = new Vector2(),\n        sdir = new Vector3(),\n        tdir = new Vector3();\n\n    function handleTriangle(a, b, c) {\n      vA.fromArray(positions, a * 3);\n      vB.fromArray(positions, b * 3);\n      vC.fromArray(positions, c * 3);\n      uvA.fromArray(uvs, a * 2);\n      uvB.fromArray(uvs, b * 2);\n      uvC.fromArray(uvs, c * 2);\n      vB.sub(vA);\n      vC.sub(vA);\n      uvB.sub(uvA);\n      uvC.sub(uvA);\n      var r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y); // silently ignore degenerate uv triangles having coincident or colinear vertices\n\n      if (!isFinite(r)) return;\n      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);\n      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);\n      tan1[a].add(sdir);\n      tan1[b].add(sdir);\n      tan1[c].add(sdir);\n      tan2[a].add(tdir);\n      tan2[b].add(tdir);\n      tan2[c].add(tdir);\n    }\n\n    var groups = geometry.groups;\n\n    if (groups.length === 0) {\n      groups = [{\n        start: 0,\n        count: indices.length\n      }];\n    }\n\n    for (var i = 0, il = groups.length; i < il; ++i) {\n      var group = groups[i];\n      var start = group.start;\n      var count = group.count;\n\n      for (var j = start, jl = start + count; j < jl; j += 3) {\n        handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);\n      }\n    }\n\n    var tmp = new Vector3(),\n        tmp2 = new Vector3();\n    var n = new Vector3(),\n        n2 = new Vector3();\n    var w, t, test;\n\n    function handleVertex(v) {\n      n.fromArray(normals, v * 3);\n      n2.copy(n);\n      t = tan1[v]; // Gram-Schmidt orthogonalize\n\n      tmp.copy(t);\n      tmp.sub(n.multiplyScalar(n.dot(t))).normalize(); // Calculate handedness\n\n      tmp2.crossVectors(n2, t);\n      test = tmp2.dot(tan2[v]);\n      w = test < 0.0 ? -1.0 : 1.0;\n      tangents[v * 4] = tmp.x;\n      tangents[v * 4 + 1] = tmp.y;\n      tangents[v * 4 + 2] = tmp.z;\n      tangents[v * 4 + 3] = w;\n    }\n\n    for (var i = 0, il = groups.length; i < il; ++i) {\n      var group = groups[i];\n      var start = group.start;\n      var count = group.count;\n\n      for (var j = start, jl = start + count; j < jl; j += 3) {\n        handleVertex(indices[j + 0]);\n        handleVertex(indices[j + 1]);\n        handleVertex(indices[j + 2]);\n      }\n    }\n  },\n\n  /**\n   * @param  {Array<BufferGeometry>} geometries\n   * @param  {Boolean} useGroups\n   * @return {BufferGeometry}\n   */\n  mergeBufferGeometries: function mergeBufferGeometries(geometries, useGroups) {\n    var isIndexed = geometries[0].index !== null;\n    var attributesUsed = new _Set(_Object$keys(geometries[0].attributes));\n    var morphAttributesUsed = new _Set(_Object$keys(geometries[0].morphAttributes));\n    var attributes = {};\n    var morphAttributes = {};\n    var morphTargetsRelative = geometries[0].morphTargetsRelative;\n    var mergedGeometry = new BufferGeometry();\n    var offset = 0;\n\n    for (var i = 0; i < geometries.length; ++i) {\n      var geometry = geometries[i]; // ensure that all geometries are indexed, or none\n\n      if (isIndexed !== (geometry.index !== null)) return null; // gather attributes, exit early if they're different\n\n      for (var name in geometry.attributes) {\n        if (!attributesUsed.has(name)) return null;\n        if (attributes[name] === undefined) attributes[name] = [];\n        attributes[name].push(geometry.attributes[name]);\n      } // gather morph attributes, exit early if they're different\n\n\n      if (morphTargetsRelative !== geometry.morphTargetsRelative) return null;\n\n      for (var name in geometry.morphAttributes) {\n        if (!morphAttributesUsed.has(name)) return null;\n        if (morphAttributes[name] === undefined) morphAttributes[name] = [];\n        morphAttributes[name].push(geometry.morphAttributes[name]);\n      } // gather .userData\n\n\n      mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n      mergedGeometry.userData.mergedUserData.push(geometry.userData);\n\n      if (useGroups) {\n        var count;\n\n        if (isIndexed) {\n          count = geometry.index.count;\n        } else if (geometry.attributes.position !== undefined) {\n          count = geometry.attributes.position.count;\n        } else {\n          return null;\n        }\n\n        mergedGeometry.addGroup(offset, count, i);\n        offset += count;\n      }\n    } // merge indices\n\n\n    if (isIndexed) {\n      var indexOffset = 0;\n      var mergedIndex = [];\n\n      for (var i = 0; i < geometries.length; ++i) {\n        var index = geometries[i].index;\n\n        for (var j = 0; j < index.count; ++j) {\n          mergedIndex.push(index.getX(j) + indexOffset);\n        }\n\n        indexOffset += geometries[i].attributes.position.count;\n      }\n\n      mergedGeometry.setIndex(mergedIndex);\n    } // merge attributes\n\n\n    for (var name in attributes) {\n      var mergedAttribute = this.mergeBufferAttributes(attributes[name]);\n      if (!mergedAttribute) return null;\n      mergedGeometry.setAttribute(name, mergedAttribute);\n    } // merge morph attributes\n\n\n    for (var name in morphAttributes) {\n      var numMorphTargets = morphAttributes[name][0].length;\n      if (numMorphTargets === 0) break;\n      mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n      mergedGeometry.morphAttributes[name] = [];\n\n      for (var i = 0; i < numMorphTargets; ++i) {\n        var morphAttributesToMerge = [];\n\n        for (var j = 0; j < morphAttributes[name].length; ++j) {\n          morphAttributesToMerge.push(morphAttributes[name][j][i]);\n        }\n\n        var mergedMorphAttribute = this.mergeBufferAttributes(morphAttributesToMerge);\n        if (!mergedMorphAttribute) return null;\n        mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n      }\n    }\n\n    return mergedGeometry;\n  },\n\n  /**\n   * @param {Array<BufferAttribute>} attributes\n   * @return {BufferAttribute}\n   */\n  mergeBufferAttributes: function mergeBufferAttributes(attributes) {\n    var TypedArray;\n    var itemSize;\n    var normalized;\n    var arrayLength = 0;\n\n    for (var i = 0; i < attributes.length; ++i) {\n      var attribute = attributes[i];\n      if (attribute.isInterleavedBufferAttribute) return null;\n      if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n      if (TypedArray !== attribute.array.constructor) return null;\n      if (itemSize === undefined) itemSize = attribute.itemSize;\n      if (itemSize !== attribute.itemSize) return null;\n      if (normalized === undefined) normalized = attribute.normalized;\n      if (normalized !== attribute.normalized) return null;\n      arrayLength += attribute.array.length;\n    }\n\n    var array = new TypedArray(arrayLength);\n    var offset = 0;\n\n    for (var i = 0; i < attributes.length; ++i) {\n      array.set(attributes[i].array, offset);\n      offset += attributes[i].array.length;\n    }\n\n    return new BufferAttribute(array, itemSize, normalized);\n  },\n\n  /**\n   * @param {Array<BufferAttribute>} attributes\n   * @return {Array<InterleavedBufferAttribute>}\n   */\n  interleaveAttributes: function interleaveAttributes(attributes) {\n    // Interleaves the provided attributes into an InterleavedBuffer and returns\n    // a set of InterleavedBufferAttributes for each attribute\n    var TypedArray;\n    var arrayLength = 0;\n    var stride = 0; // calculate the the length and type of the interleavedBuffer\n\n    for (var i = 0, l = attributes.length; i < l; ++i) {\n      var attribute = attributes[i];\n      if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n\n      if (TypedArray !== attribute.array.constructor) {\n        console.warn('AttributeBuffers of different types cannot be interleaved');\n        return null;\n      }\n\n      arrayLength += attribute.array.length;\n      stride += attribute.itemSize;\n    } // Create the set of buffer attributes\n\n\n    var interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n    var offset = 0;\n    var res = [];\n    var getters = ['getX', 'getY', 'getZ', 'getW'];\n    var setters = ['setX', 'setY', 'setZ', 'setW'];\n\n    for (var j = 0, l = attributes.length; j < l; j++) {\n      var attribute = attributes[j];\n      var itemSize = attribute.itemSize;\n      var count = attribute.count;\n      var iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n      res.push(iba);\n      offset += itemSize; // Move the data for each attribute into the new interleavedBuffer\n      // at the appropriate offset\n\n      for (var c = 0; c < count; c++) {\n        for (var k = 0; k < itemSize; k++) {\n          iba[setters[k]](c, attribute[getters[k]](c));\n        }\n      }\n    }\n\n    return res;\n  },\n\n  /**\n   * @param {Array<BufferGeometry>} geometry\n   * @return {number}\n   */\n  estimateBytesUsed: function estimateBytesUsed(geometry) {\n    // Return the estimated memory used by this geometry in bytes\n    // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n    // for InterleavedBufferAttributes.\n    var mem = 0;\n\n    for (var name in geometry.attributes) {\n      var attr = geometry.getAttribute(name);\n      mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n    }\n\n    var indices = geometry.getIndex();\n    mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n    return mem;\n  },\n\n  /**\n   * @param {BufferGeometry} geometry\n   * @param {number} tolerance\n   * @return {BufferGeometry>}\n   */\n  mergeVertices: function mergeVertices(geometry) {\n    var tolerance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-4;\n    tolerance = Math.max(tolerance, _Number$EPSILON); // Generate an index buffer if the geometry doesn't have one, or optimize it\n    // if it's already available.\n\n    var hashToIndex = {};\n    var indices = geometry.getIndex();\n    var positions = geometry.getAttribute('position');\n    var vertexCount = indices ? indices.count : positions.count; // next value for triangle indices\n\n    var nextIndex = 0; // attributes and new attribute arrays\n\n    var attributeNames = _Object$keys(geometry.attributes);\n\n    var attrArrays = {};\n    var morphAttrsArrays = {};\n    var newIndices = [];\n    var getters = ['getX', 'getY', 'getZ', 'getW']; // initialize the arrays\n\n    for (var i = 0, l = attributeNames.length; i < l; i++) {\n      var name = attributeNames[i];\n      attrArrays[name] = [];\n      var morphAttr = geometry.morphAttributes[name];\n\n      if (morphAttr) {\n        morphAttrsArrays[name] = new Array(morphAttr.length).fill().map(function () {\n          return [];\n        });\n      }\n    } // convert the error tolerance to an amount of decimal places to truncate to\n\n\n    var decimalShift = Math.log10(1 / tolerance);\n    var shiftMultiplier = Math.pow(10, decimalShift);\n\n    for (var i = 0; i < vertexCount; i++) {\n      var index = indices ? indices.getX(i) : i; // Generate a hash for the vertex attributes at the current index 'i'\n\n      var hash = '';\n\n      for (var j = 0, l = attributeNames.length; j < l; j++) {\n        var name = attributeNames[j];\n        var attribute = geometry.getAttribute(name);\n        var itemSize = attribute.itemSize;\n\n        for (var k = 0; k < itemSize; k++) {\n          // double tilde truncates the decimal value\n          hash += \"\".concat(~~(attribute[getters[k]](index) * shiftMultiplier), \",\");\n        }\n      } // Add another reference to the vertex if it's already\n      // used by another index\n\n\n      if (hash in hashToIndex) {\n        newIndices.push(hashToIndex[hash]);\n      } else {\n        // copy data to the new index in the attribute arrays\n        for (var j = 0, l = attributeNames.length; j < l; j++) {\n          var name = attributeNames[j];\n          var attribute = geometry.getAttribute(name);\n          var morphAttr = geometry.morphAttributes[name];\n          var itemSize = attribute.itemSize;\n          var newarray = attrArrays[name];\n          var newMorphArrays = morphAttrsArrays[name];\n\n          for (var k = 0; k < itemSize; k++) {\n            var getterFunc = getters[k];\n            newarray.push(attribute[getterFunc](index));\n\n            if (morphAttr) {\n              for (var m = 0, ml = morphAttr.length; m < ml; m++) {\n                newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n              }\n            }\n          }\n        }\n\n        hashToIndex[hash] = nextIndex;\n        newIndices.push(nextIndex);\n        nextIndex++;\n      }\n    } // Generate typed arrays from new attribute arrays and update\n    // the attributeBuffers\n\n\n    var result = geometry.clone();\n\n    for (var i = 0, l = attributeNames.length; i < l; i++) {\n      var name = attributeNames[i];\n      var oldAttribute = geometry.getAttribute(name);\n      var buffer = new oldAttribute.array.constructor(attrArrays[name]);\n      var attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n      result.setAttribute(name, attribute); // Update the attribute arrays\n\n      if (name in morphAttrsArrays) {\n        for (var j = 0; j < morphAttrsArrays[name].length; j++) {\n          var oldMorphAttribute = geometry.morphAttributes[name][j];\n          var buffer = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n          var morphAttribute = new BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n          result.morphAttributes[name][j] = morphAttribute;\n        }\n      }\n    } // indices\n\n\n    result.setIndex(newIndices);\n    return result;\n  },\n\n  /**\n   * @param {BufferGeometry} geometry\n   * @param {number} drawMode\n   * @return {BufferGeometry>}\n   */\n  toTrianglesDrawMode: function toTrianglesDrawMode(geometry, drawMode) {\n    if (drawMode === TrianglesDrawMode) {\n      console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');\n      return geometry;\n    }\n\n    if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n      var index = geometry.getIndex(); // generate index if not present\n\n      if (index === null) {\n        var indices = [];\n        var position = geometry.getAttribute('position');\n\n        if (position !== undefined) {\n          for (var i = 0; i < position.count; i++) {\n            indices.push(i);\n          }\n\n          geometry.setIndex(indices);\n          index = geometry.getIndex();\n        } else {\n          console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n          return geometry;\n        }\n      } //\n\n\n      var numberOfTriangles = index.count - 2;\n      var newIndices = [];\n\n      if (drawMode === TriangleFanDrawMode) {\n        // gl.TRIANGLE_FAN\n        for (var i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        // gl.TRIANGLE_STRIP\n        for (var i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n\n      if (newIndices.length / 3 !== numberOfTriangles) {\n        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n      } // build final geometry\n\n\n      var newGeometry = geometry.clone();\n      newGeometry.setIndex(newIndices);\n      newGeometry.clearGroups();\n      return newGeometry;\n    } else {\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);\n      return geometry;\n    }\n  }\n};\nexport { BufferGeometryUtils };","map":{"version":3,"sources":["/Users/alexiaperesson/site-aperesso/node_modules/three/examples/jsm/utils/BufferGeometryUtils.js"],"names":["BufferAttribute","BufferGeometry","InterleavedBuffer","InterleavedBufferAttribute","TriangleFanDrawMode","TriangleStripDrawMode","TrianglesDrawMode","Vector2","Vector3","BufferGeometryUtils","computeTangents","geometry","index","attributes","position","undefined","normal","uv","console","warn","indices","array","positions","normals","uvs","nVertices","length","tangent","setAttribute","Float32Array","tangents","tan1","tan2","i","vA","vB","vC","uvA","uvB","uvC","sdir","tdir","handleTriangle","a","b","c","fromArray","sub","r","x","y","isFinite","copy","multiplyScalar","addScaledVector","add","groups","start","count","il","group","j","jl","tmp","tmp2","n","n2","w","t","test","handleVertex","v","dot","normalize","crossVectors","z","mergeBufferGeometries","geometries","useGroups","isIndexed","attributesUsed","morphAttributesUsed","morphAttributes","morphTargetsRelative","mergedGeometry","offset","name","has","push","userData","mergedUserData","addGroup","indexOffset","mergedIndex","getX","setIndex","mergedAttribute","mergeBufferAttributes","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","TypedArray","itemSize","normalized","arrayLength","attribute","isInterleavedBufferAttribute","constructor","set","interleaveAttributes","stride","l","interleavedBuffer","res","getters","setters","iba","k","estimateBytesUsed","mem","attr","getAttribute","BYTES_PER_ELEMENT","getIndex","mergeVertices","tolerance","Math","max","hashToIndex","vertexCount","nextIndex","attributeNames","attrArrays","morphAttrsArrays","newIndices","morphAttr","Array","fill","map","decimalShift","log10","shiftMultiplier","pow","hash","newarray","newMorphArrays","getterFunc","m","ml","result","clone","oldAttribute","buffer","oldMorphAttribute","morphAttribute","toTrianglesDrawMode","drawMode","error","numberOfTriangles","newGeometry","clearGroups"],"mappings":"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","sourcesContent":["/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nimport {\n\tBufferAttribute,\n\tBufferGeometry,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector2,\n\tVector3\n} from \"../../../build/three.module.js\";\n\nvar BufferGeometryUtils = {\n\n\tcomputeTangents: function ( geometry ) {\n\n\t\tvar index = geometry.index;\n\t\tvar attributes = geometry.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar indices = index.array;\n\t\tvar positions = attributes.position.array;\n\t\tvar normals = attributes.normal.array;\n\t\tvar uvs = attributes.uv.array;\n\n\t\tvar nVertices = positions.length / 3;\n\n\t\tif ( attributes.tangent === undefined ) {\n\n\t\t\tgeometry.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );\n\n\t\t}\n\n\t\tvar tangents = attributes.tangent.array;\n\n\t\tvar tan1 = [], tan2 = [];\n\n\t\tfor ( var i = 0; i < nVertices; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tvar vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\tvC.fromArray( positions, c * 3 );\n\n\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\tuvC.fromArray( uvs, c * 2 );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tvar r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tvar groups = geometry.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: indices.length\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( var i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tvar group = groups[ i ];\n\n\t\t\tvar start = group.start;\n\t\t\tvar count = group.count;\n\n\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindices[ j + 0 ],\n\t\t\t\t\tindices[ j + 1 ],\n\t\t\t\t\tindices[ j + 2 ]\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar tmp = new Vector3(), tmp2 = new Vector3();\n\t\tvar n = new Vector3(), n2 = new Vector3();\n\t\tvar w, t, test;\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromArray( normals, v * 3 );\n\t\t\tn2.copy( n );\n\n\t\t\tt = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\ttest = tmp2.dot( tan2[ v ] );\n\t\t\tw = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangents[ v * 4 ] = tmp.x;\n\t\t\ttangents[ v * 4 + 1 ] = tmp.y;\n\t\t\ttangents[ v * 4 + 2 ] = tmp.z;\n\t\t\ttangents[ v * 4 + 3 ] = w;\n\n\t\t}\n\n\t\tfor ( var i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tvar group = groups[ i ];\n\n\t\t\tvar start = group.start;\n\t\t\tvar count = group.count;\n\n\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( indices[ j + 0 ] );\n\t\t\t\thandleVertex( indices[ j + 1 ] );\n\t\t\t\thandleVertex( indices[ j + 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t/**\n\t * @param  {Array<BufferGeometry>} geometries\n\t * @param  {Boolean} useGroups\n\t * @return {BufferGeometry}\n\t */\n\tmergeBufferGeometries: function ( geometries, useGroups ) {\n\n\t\tvar isIndexed = geometries[ 0 ].index !== null;\n\n\t\tvar attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\t\tvar morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\t\tvar attributes = {};\n\t\tvar morphAttributes = {};\n\n\t\tvar morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\t\tvar mergedGeometry = new BufferGeometry();\n\n\t\tvar offset = 0;\n\n\t\tfor ( var i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tvar geometry = geometries[ i ];\n\n\t\t\t// ensure that all geometries are indexed, or none\n\n\t\t\tif ( isIndexed !== ( geometry.index !== null ) ) return null;\n\n\t\t\t// gather attributes, exit early if they're different\n\n\t\t\tfor ( var name in geometry.attributes ) {\n\n\t\t\t\tif ( ! attributesUsed.has( name ) ) return null;\n\n\t\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\t}\n\n\t\t\t// gather morph attributes, exit early if they're different\n\n\t\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) return null;\n\n\t\t\tfor ( var name in geometry.morphAttributes ) {\n\n\t\t\t\tif ( ! morphAttributesUsed.has( name ) ) return null;\n\n\t\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t\t}\n\n\t\t\t// gather .userData\n\n\t\t\tmergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n\t\t\tmergedGeometry.userData.mergedUserData.push( geometry.userData );\n\n\t\t\tif ( useGroups ) {\n\n\t\t\t\tvar count;\n\n\t\t\t\tif ( isIndexed ) {\n\n\t\t\t\t\tcount = geometry.index.count;\n\n\t\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\t\toffset += count;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// merge indices\n\n\t\tif ( isIndexed ) {\n\n\t\t\tvar indexOffset = 0;\n\t\t\tvar mergedIndex = [];\n\n\t\t\tfor ( var i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tvar index = geometries[ i ].index;\n\n\t\t\t\tfor ( var j = 0; j < index.count; ++ j ) {\n\n\t\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t\t}\n\n\t\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t\t}\n\n\t\t// merge attributes\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar mergedAttribute = this.mergeBufferAttributes( attributes[ name ] );\n\n\t\t\tif ( ! mergedAttribute ) return null;\n\n\t\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t\t}\n\n\t\t// merge morph attributes\n\n\t\tfor ( var name in morphAttributes ) {\n\n\t\t\tvar numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\t\tif ( numMorphTargets === 0 ) break;\n\n\t\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\t\tfor ( var i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\t\tvar morphAttributesToMerge = [];\n\n\t\t\t\tfor ( var j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tvar mergedMorphAttribute = this.mergeBufferAttributes( morphAttributesToMerge );\n\n\t\t\t\tif ( ! mergedMorphAttribute ) return null;\n\n\t\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn mergedGeometry;\n\n\t},\n\n\t/**\n\t * @param {Array<BufferAttribute>} attributes\n\t * @return {BufferAttribute}\n\t */\n\tmergeBufferAttributes: function ( attributes ) {\n\n\t\tvar TypedArray;\n\t\tvar itemSize;\n\t\tvar normalized;\n\t\tvar arrayLength = 0;\n\n\t\tfor ( var i = 0; i < attributes.length; ++ i ) {\n\n\t\t\tvar attribute = attributes[ i ];\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) return null;\n\n\t\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\t\tif ( TypedArray !== attribute.array.constructor ) return null;\n\n\t\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\t\tif ( itemSize !== attribute.itemSize ) return null;\n\n\t\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\t\tif ( normalized !== attribute.normalized ) return null;\n\n\t\t\tarrayLength += attribute.array.length;\n\n\t\t}\n\n\t\tvar array = new TypedArray( arrayLength );\n\t\tvar offset = 0;\n\n\t\tfor ( var i = 0; i < attributes.length; ++ i ) {\n\n\t\t\tarray.set( attributes[ i ].array, offset );\n\n\t\t\toffset += attributes[ i ].array.length;\n\n\t\t}\n\n\t\treturn new BufferAttribute( array, itemSize, normalized );\n\n\t},\n\n\t/**\n\t * @param {Array<BufferAttribute>} attributes\n\t * @return {Array<InterleavedBufferAttribute>}\n\t */\n\tinterleaveAttributes: function ( attributes ) {\n\n\t\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t\t// a set of InterleavedBufferAttributes for each attribute\n\t\tvar TypedArray;\n\t\tvar arrayLength = 0;\n\t\tvar stride = 0;\n\n\t\t// calculate the the length and type of the interleavedBuffer\n\t\tfor ( var i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\t\tvar attribute = attributes[ i ];\n\n\t\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\t\tconsole.warn( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tarrayLength += attribute.array.length;\n\t\t\tstride += attribute.itemSize;\n\n\t\t}\n\n\t\t// Create the set of buffer attributes\n\t\tvar interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\t\tvar offset = 0;\n\t\tvar res = [];\n\t\tvar getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\t\tvar setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t\tfor ( var j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\t\tvar attribute = attributes[ j ];\n\t\t\tvar itemSize = attribute.itemSize;\n\t\t\tvar count = attribute.count;\n\t\t\tvar iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\t\tres.push( iba );\n\n\t\t\toffset += itemSize;\n\n\t\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t\t// at the appropriate offset\n\t\t\tfor ( var c = 0; c < count; c ++ ) {\n\n\t\t\t\tfor ( var k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn res;\n\n\t},\n\n\t/**\n\t * @param {Array<BufferGeometry>} geometry\n\t * @return {number}\n\t */\n\testimateBytesUsed: function ( geometry ) {\n\n\t\t// Return the estimated memory used by this geometry in bytes\n\t\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t\t// for InterleavedBufferAttributes.\n\t\tvar mem = 0;\n\t\tfor ( var name in geometry.attributes ) {\n\n\t\t\tvar attr = geometry.getAttribute( name );\n\t\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t\t}\n\n\t\tvar indices = geometry.getIndex();\n\t\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\t\treturn mem;\n\n\t},\n\n\t/**\n\t * @param {BufferGeometry} geometry\n\t * @param {number} tolerance\n\t * @return {BufferGeometry>}\n\t */\n\tmergeVertices: function ( geometry, tolerance = 1e-4 ) {\n\n\t\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t\t// if it's already available.\n\t\tvar hashToIndex = {};\n\t\tvar indices = geometry.getIndex();\n\t\tvar positions = geometry.getAttribute( 'position' );\n\t\tvar vertexCount = indices ? indices.count : positions.count;\n\n\t\t// next value for triangle indices\n\t\tvar nextIndex = 0;\n\n\t\t// attributes and new attribute arrays\n\t\tvar attributeNames = Object.keys( geometry.attributes );\n\t\tvar attrArrays = {};\n\t\tvar morphAttrsArrays = {};\n\t\tvar newIndices = [];\n\t\tvar getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\n\t\t// initialize the arrays\n\t\tfor ( var i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\t\tvar name = attributeNames[ i ];\n\n\t\t\tattrArrays[ name ] = [];\n\n\t\t\tvar morphAttr = geometry.morphAttributes[ name ];\n\t\t\tif ( morphAttr ) {\n\n\t\t\t\tmorphAttrsArrays[ name ] = new Array( morphAttr.length ).fill().map( () => [] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// convert the error tolerance to an amount of decimal places to truncate to\n\t\tvar decimalShift = Math.log10( 1 / tolerance );\n\t\tvar shiftMultiplier = Math.pow( 10, decimalShift );\n\t\tfor ( var i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tvar index = indices ? indices.getX( i ) : i;\n\n\t\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\t\tvar hash = '';\n\t\t\tfor ( var j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tvar name = attributeNames[ j ];\n\t\t\t\tvar attribute = geometry.getAttribute( name );\n\t\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\t\tfor ( var k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Add another reference to the vertex if it's already\n\t\t\t// used by another index\n\t\t\tif ( hash in hashToIndex ) {\n\n\t\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t\t} else {\n\n\t\t\t\t// copy data to the new index in the attribute arrays\n\t\t\t\tfor ( var j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\t\tvar name = attributeNames[ j ];\n\t\t\t\t\tvar attribute = geometry.getAttribute( name );\n\t\t\t\t\tvar morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\t\tvar itemSize = attribute.itemSize;\n\t\t\t\t\tvar newarray = attrArrays[ name ];\n\t\t\t\t\tvar newMorphArrays = morphAttrsArrays[ name ];\n\n\t\t\t\t\tfor ( var k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\t\tvar getterFunc = getters[ k ];\n\t\t\t\t\t\tnewarray.push( attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\t\tfor ( var m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\t\tnewMorphArrays[ m ].push( morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\t\tnewIndices.push( nextIndex );\n\t\t\t\tnextIndex ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Generate typed arrays from new attribute arrays and update\n\t\t// the attributeBuffers\n\t\tconst result = geometry.clone();\n\t\tfor ( var i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\t\tvar name = attributeNames[ i ];\n\t\t\tvar oldAttribute = geometry.getAttribute( name );\n\n\t\t\tvar buffer = new oldAttribute.array.constructor( attrArrays[ name ] );\n\t\t\tvar attribute = new BufferAttribute( buffer, oldAttribute.itemSize, oldAttribute.normalized );\n\n\t\t\tresult.setAttribute( name, attribute );\n\n\t\t\t// Update the attribute arrays\n\t\t\tif ( name in morphAttrsArrays ) {\n\n\t\t\t\tfor ( var j = 0; j < morphAttrsArrays[ name ].length; j ++ ) {\n\n\t\t\t\t\tvar oldMorphAttribute = geometry.morphAttributes[ name ][ j ];\n\n\t\t\t\t\tvar buffer = new oldMorphAttribute.array.constructor( morphAttrsArrays[ name ][ j ] );\n\t\t\t\t\tvar morphAttribute = new BufferAttribute( buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized );\n\t\t\t\t\tresult.morphAttributes[ name ][ j ] = morphAttribute;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indices\n\n\t\tresult.setIndex( newIndices );\n\n\t\treturn result;\n\n\t},\n\n\t/**\n\t * @param {BufferGeometry} geometry\n\t * @param {number} drawMode\n\t * @return {BufferGeometry>}\n\t */\n\ttoTrianglesDrawMode: function ( geometry, drawMode ) {\n\n\t\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\t\tvar index = geometry.getIndex();\n\n\t\t\t// generate index if not present\n\n\t\t\tif ( index === null ) {\n\n\t\t\t\tvar indices = [];\n\n\t\t\t\tvar position = geometry.getAttribute( 'position' );\n\n\t\t\t\tif ( position !== undefined ) {\n\n\t\t\t\t\tfor ( var i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\t\tindices.push( i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\t\treturn geometry;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar numberOfTriangles = index.count - 2;\n\t\t\tvar newIndices = [];\n\n\t\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\t\tfor ( var i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\t\tfor ( var i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t\t}\n\n\t\t\t// build final geometry\n\n\t\t\tvar newGeometry = geometry.clone();\n\t\t\tnewGeometry.setIndex( newIndices );\n\t\t\tnewGeometry.clearGroups();\n\n\t\t\treturn newGeometry;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t}\n\n};\n\nexport { BufferGeometryUtils };\n"]},"metadata":{},"sourceType":"module"}